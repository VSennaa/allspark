# app.py
# Caminho sugerido: ./app.py

import cv2
import time
import threading
import numpy as np
from flask import Flask, Response, render_template_string, request

# ============================================================================
# 1. VARI√ÅVEIS GLOBAIS E CONFIGURA√á√ïES
# ============================================================================
frame_raw = None
frame_output = None
lock = threading.Lock()
app = Flask(__name__)

# --- Estados do Sistema ---
CURRENT_MODE = 'RAW'
FLIP_CAMERA = False

# --- ROI (Recorte) ---
ROI_TOP = 0.0
ROI_BOTTOM = 1.0
ROI_LEFT = 0.0
ROI_RIGHT = 1.0

# --- Par√¢metros de Detec√ß√£o ---
GAMMA_VALUE = 1.0
INVERTED_THRESH = 180
MIN_AREA = 10
MAX_OIL_AREA = 300
SHIP_CIRCULARITY_THRESH = 0.82
SKELETON_SAMPLING = 5

# ============================================================================
# 2. PROCESSAMENTO VISUAL
# ============================================================================

def adjust_gamma(image, gamma=1.0):
    if gamma == 1.0: return image
    invGamma = 1.0 / gamma
    table = np.array([((i / 255.0) ** invGamma) * 255 for i in np.arange(0, 256)]).astype("uint8")
    return cv2.LUT(image, table)

def apply_clahe(image):
    try:
        lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)
        l, a, b = cv2.split(lab)
        clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8,8))
        cl = clahe.apply(l)
        limg = cv2.merge((cl, a, b))
        return cv2.cvtColor(limg, cv2.COLOR_LAB2BGR)
    except:
        return image

def verificar_borda(cnt, width, height, margin=5):
    x, y, w, h = cv2.boundingRect(cnt)
    toca_topo = (y <= margin)
    toca_fundo = (y + h >= height - margin)
    toca_esq = (x <= margin)
    toca_dir = (x + w >= width - margin)
    if toca_topo or toca_fundo or toca_esq or toca_dir:
        return True
    return False

def desenhar_pontos_traco(img, cnt):
    peri = cv2.arcLength(cnt, True)
    approx = cv2.approxPolyDP(cnt, 0.01 * peri, False)
    pontos = approx.reshape(-1, 2)
    if len(pontos) > SKELETON_SAMPLING:
        indices = np.linspace(0, len(pontos) - 1, SKELETON_SAMPLING).astype(int)
        pontos_para_desenhar = pontos[indices]
    else:
        pontos_para_desenhar = pontos

    for point in pontos_para_desenhar:
        px, py = int(point[0]), int(point[1])
        cv2.circle(img, (px, py), 3, (0, 255, 255), -1)

def _choose_label_position(img_w, img_h, bbox, text_w, text_h, margin=10):
    """
    Tenta posicionar o r√≥tulo fora de bbox na ordem: direita, esquerda, topo, fundo.
    Retorna (label_x, label_y) top-left do texto.
    bbox = (x_min, y_min, x_max, y_max)
    """
    x_min, y_min, x_max, y_max = bbox

    # direita
    lx = x_max + margin
    ly = y_min
    if lx + text_w + margin < img_w:
        ly = max(margin, min(ly, img_h - text_h - margin))
        return int(lx), int(ly)

    # esquerda
    lx = x_min - margin - text_w
    ly = y_min
    if lx > margin:
        ly = max(margin, min(ly, img_h - text_h - margin))
        return int(lx), int(ly)

    # acima
    lx = x_min
    ly = y_min - margin - text_h
    if ly > margin:
        lx = max(margin, min(lx, img_w - text_w - margin))
        return int(lx), int(ly)

    # abaixo
    lx = x_min
    ly = y_max + margin
    if ly + text_h + margin < img_h:
        lx = max(margin, min(lx, img_w - text_w - margin))
        return int(lx), int(ly)

    # fallback: canto superior direito com margem
    return int(img_w - text_w - margin), int(margin)

def desenhar_indicador(img, cnt, area, circularity, tipo):
    """
    Desenha o indicador e posiciona o r√≥tulo FORA da caixa que envolve o contorno.
    """
    h_img, w_img = img.shape[:2]
    area_total_roi = h_img * w_img
    pct_area = (area / area_total_roi) * 100 if area_total_roi > 0 else 0.0

    color = (0, 0, 255)  # default vermelho
    cx, cy = 0, 0
    label_text = ""
    margin = 10
    # Determinar bbox (x_min,y_min,x_max,y_max) referente ao contorno desenhado
    if tipo == "TRACO":
        rect = cv2.minAreaRect(cnt)
        box = cv2.boxPoints(rect)
        box = np.int64(box)
        cv2.drawContours(img, [box], 0, color, 2)
        cx, cy = int(rect[0][0]), int(rect[0][1])
        # bbox a partir do box
        xs = box[:,0]; ys = box[:,1]
        x_min, x_max = int(xs.min()), int(xs.max())
        y_min, y_max = int(ys.min()), int(ys.max())
        # desenhar pontos internos (esqueleto) sem texto
        desenhar_pontos_traco(img, cnt)
    else:
        (x, y), radius = cv2.minEnclosingCircle(cnt)
        center = (int(x), int(y))
        radius = int(radius)
        if tipo == "NAVIO":
            color = (255, 200, 0)
        cv2.circle(img, center, radius + 5, color, 2)
        cx, cy = int(x), int(y)
        x_min = cx - (radius + 5)
        x_max = cx + (radius + 5)
        y_min = cy - (radius + 5)
        y_max = cy + (radius + 5)

    # Preparar texto: tipo, percentual e coordenadas (centro)
    label_text = f"{tipo} {pct_area:.2f}% (px:{int(area)})"
    coord_text = f"({cx},{cy})"
    # medir tamanhos de texto
    font = cv2.FONT_HERSHEY_SIMPLEX
    font_scale = 0.45
    thickness = 1
    (tw, th), _ = cv2.getTextSize(label_text, font, font_scale, thickness)
    (cw, ch), _ = cv2.getTextSize(coord_text, font, font_scale, thickness)

    # escolher posi√ß√£o para o bloco de texto (colocamos label_text e abaixo coord_text)
    total_h = th + 4 + ch
    total_w = max(tw, cw)
    bbox = (x_min, y_min, x_max, y_max)
    label_x, label_y = _choose_label_position(w_img, h_img, bbox, total_w, total_h, margin=margin)

    # desenhar linha do centro at√© ponto mais pr√≥ximo do r√≥tulo
    # calcular ponto de liga√ß√£o (pegamos o centro do bbox)
    box_cx = int((x_min + x_max) / 2)
    box_cy = int((y_min + y_max) / 2)
    # conectar centro real (cx,cy) com ponto m√©dio da borda do r√≥tulo
    text_anchor_x = label_x
    text_anchor_y = label_y + int(total_h / 2)
    cv2.line(img, (cx, cy), (text_anchor_x - 5 if text_anchor_x > cx else text_anchor_x + total_w + 5, text_anchor_y), color, 1)

    # desenhar ret√¢ngulo leve de fundo para texto (melhora legibilidade)
    rect_bg_pt1 = (label_x - 4, label_y - 2)
    rect_bg_pt2 = (label_x + total_w + 4, label_y + total_h + 2)
    overlay = img.copy()
    cv2.rectangle(overlay, rect_bg_pt1, rect_bg_pt2, (0,0,0), -1)
    alpha = 0.45
    cv2.addWeighted(overlay, alpha, img, 1 - alpha, 0, img)

    # desenhar textos: primeiro label, depois coordenadas em linha abaixo
    cv2.putText(img, label_text, (label_x, label_y + th), font, font_scale, color, thickness, cv2.LINE_AA)
    cv2.putText(img, coord_text, (label_x, label_y + th + 4 + ch), font, font_scale, (200,200,200), thickness, cv2.LINE_AA)

def processar_frame(frame, mode='DETECT'):
    global MIN_AREA, INVERTED_THRESH, MAX_OIL_AREA, SHIP_CIRCULARITY_THRESH
    if frame is None: return None

    # 1. RECORTE
    height, width = frame.shape[:2]
    y1 = int(height * max(0.0, min(ROI_TOP, ROI_BOTTOM)))
    y2 = int(height * max(0.0, min(ROI_BOTTOM, 1.0)))
    x1 = int(width * max(0.0, min(ROI_LEFT, ROI_RIGHT)))
    x2 = int(width * max(0.0, min(ROI_RIGHT, 1.0)))
    
    if (y2 - y1) < 10 or (x2 - x1) < 10: roi = frame
    else: roi = frame[y1:y2, x1:x2]
    
    h_roi, w_roi = roi.shape[:2]

    # 2. Pr√©-processamento
    roi = apply_clahe(roi)
    roi = adjust_gamma(roi, GAMMA_VALUE)

    # 3. Binariza√ß√£o
    gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
    inverted = cv2.bitwise_not(gray)
    _, binary = cv2.threshold(inverted, INVERTED_THRESH, 255, cv2.THRESH_BINARY)
    
    # 4. Morfologia
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))
    binary = cv2.dilate(binary, kernel, iterations=2) 
    binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

    if mode == 'DEBUG': 
        debug_view = cv2.cvtColor(binary, cv2.COLOR_GRAY2BGR)
        cv2.rectangle(debug_view, (0,0), (w_roi, h_roi), (0,0,255), 10)
        return debug_view

    # 5. An√°lise
    contours, _ = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    output_view = roi.copy()
    oleo_detectado = False
    contours = sorted(contours, key=cv2.contourArea, reverse=True)

    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area < MIN_AREA: continue 

        # FILTRO DE BORDA (Ignora Moldura)
        if verificar_borda(cnt, w_roi, h_roi, margin=4):
            continue

        perimeter = cv2.arcLength(cnt, True)
        if perimeter == 0: continue
        circularity = 4 * np.pi * (area / (perimeter * perimeter))
        
        # Classifica√ß√£o
        if circularity >= 0.65:
            if area > MAX_OIL_AREA and circularity >= SHIP_CIRCULARITY_THRESH:
                desenhar_indicador(output_view, cnt, area, circularity, "NAVIO")
            else:
                if not oleo_detectado:
                    desenhar_indicador(output_view, cnt, area, circularity, "GOTA")
                    oleo_detectado = True
                else:
                    cv2.drawContours(output_view, [cnt], -1, (0,0,255), 1)
        else:
            if not oleo_detectado:
                desenhar_indicador(output_view, cnt, area, circularity, "TRACO")
                oleo_detectado = True
            else:
                cv2.drawContours(output_view, [cnt], -1, (0,0,255), 1)

    return output_view

# ============================================================================
# DETEC√á√ÉO GEOM√âTRICA (AUTO CROP)
# ============================================================================
def detectar_canvas_geometrico(img):
    global ROI_TOP, ROI_BOTTOM, ROI_LEFT, ROI_RIGHT
    h_img, w_img = img.shape[:2]
    
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (7, 7), 0)
    edged = cv2.Canny(blurred, 30, 100)
    kernel = np.ones((5,5), np.uint8)
    edged = cv2.dilate(edged, kernel, iterations=2)

    contours, _ = cv2.findContours(edged, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    contours = sorted(contours, key=cv2.contourArea, reverse=True)[:5]

    found_rect = None

    for c in contours:
        peri = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, 0.02 * peri, True)
        if len(approx) == 4:
            area = cv2.contourArea(c)
            if area > (w_img * h_img * 0.1): 
                found_rect = approx
                break
    
    if found_rect is not None:
        x, y, w, h = cv2.boundingRect(found_rect)
        margin_x = int(w * 0.05)
        margin_y = int(h * 0.05)
        x_new = x + margin_x
        y_new = y + margin_y
        w_new = w - (2 * margin_x)
        h_new = h - (2 * margin_y)
        
        ROI_LEFT = max(0.0, x_new / w_img)
        ROI_TOP = max(0.0, y_new / h_img)
        ROI_RIGHT = min(1.0, (x_new + w_new) / w_img)
        ROI_BOTTOM = min(1.0, (y_new + h_new) / h_img)
        return True
    return False

# ============================================================================
# C√ÇMERA E SERVIDOR
# ============================================================================
def camera_loop():
    global frame_raw, frame_output
    backend = cv2.CAP_V4L2
    cap = cv2.VideoCapture(0, backend)
    if not cap.isOpened(): cap = cv2.VideoCapture(1, backend)
    cap.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'))
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
    
    while True:
        ret, frame = cap.read()
        if ret:
            with lock: frame_raw = frame
            if FLIP_CAMERA: frame = cv2.flip(frame, -1)
            
            if CURRENT_MODE == 'RAW': frame_output = frame
            elif CURRENT_MODE == 'DETECT': frame_output = processar_frame(frame, mode='DETECT')
            elif CURRENT_MODE == 'DEBUG': frame_output = processar_frame(frame, mode='DEBUG')
        else:
            time.sleep(2)
            cap.open(0, backend)
        time.sleep(0.01)

def gerar_frames():
    global frame_output
    while True:
        with lock:
            if frame_output is None:
                img = np.zeros((480, 640, 3), dtype=np.uint8)
                cv2.putText(img, "AGUARDANDO CAMERA...", (150, 240), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
                out = img
            else: out = frame_output
            flag, encoded = cv2.imencode(".jpg", out, [int(cv2.IMWRITE_JPEG_QUALITY), 60])
            if not flag: continue
        yield(b'--frame\r\nContent-Type: image/jpeg\r\n\r\n' + bytearray(encoded) + b'\r\n')
        time.sleep(0.05)

@app.route("/")
def index(): return render_template_string(HTML_INDEX)

@app.route("/video_stream")
def video_stream(): return Response(gerar_frames(), mimetype="multipart/x-mixed-replace; boundary=frame")

@app.route("/set_mode/<mode>")
def set_mode(mode):
    global CURRENT_MODE
    if mode in ['RAW', 'DETECT', 'DEBUG']:
        with lock: CURRENT_MODE = mode
    return "OK"

@app.route("/trigger_auto_crop")
def trigger_auto_crop():
    global FLIP_CAMERA, CURRENT_MODE
    with lock:
        if frame_raw is not None:
            if not FLIP_CAMERA: frame_test = cv2.flip(frame_raw, -1)
            else: frame_test = frame_raw
            
            sucesso = detectar_canvas_geometrico(frame_test)
            if sucesso:
                FLIP_CAMERA = True
                CURRENT_MODE = 'DETECT'
                return "Sucesso! Canvas Detectado."
            else:
                return "Falha no Auto-Crop. Use sliders manuais."
    return "Erro camera"

@app.route("/update_roi", methods=['POST'])
def update_roi():
    global ROI_TOP, ROI_BOTTOM, ROI_LEFT, ROI_RIGHT, FLIP_CAMERA, CURRENT_MODE
    data = request.json
    with lock:
        ROI_TOP = float(data['top']) / 100.0
        ROI_BOTTOM = float(data['bottom']) / 100.0
        ROI_LEFT = float(data['left']) / 100.0
        ROI_RIGHT = float(data['right']) / 100.0
        FLIP_CAMERA = True
        CURRENT_MODE = 'DETECT'
    return "ROI Updated"

@app.route("/update_params", methods=['POST'])
def update_params():
    global GAMMA_VALUE, INVERTED_THRESH, MAX_OIL_AREA, SHIP_CIRCULARITY_THRESH
    data = request.json
    GAMMA_VALUE = float(data['gamma'])
    INVERTED_THRESH = int(data['inverted_thresh'])
    MAX_OIL_AREA = int(data['max_oil_area'])
    SHIP_CIRCULARITY_THRESH = float(data['ship_circ'])
    return "OK"

@app.route("/reset_view")
def reset_view():
    global ROI_TOP, ROI_BOTTOM, ROI_LEFT, ROI_RIGHT, CURRENT_MODE, FLIP_CAMERA
    with lock:
        ROI_TOP, ROI_LEFT, ROI_BOTTOM, ROI_RIGHT = 0.0, 0.0, 1.0, 1.0
        CURRENT_MODE = 'RAW'
        FLIP_CAMERA = False
    return "Reset OK"

HTML_INDEX = """
<!DOCTYPE html>
<html>
<head>
    <title>Sistema de Vis√£o Ultimate (Auto)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { background: #121212; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; text-align: center; margin: 0; padding-bottom: 50px;}
        .container { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-top: 20px; }
        .video-container { border: 2px solid #444; display: inline-block; position: relative; }
        .panel { background: #1e1e1e; padding: 20px; border-radius: 8px; width: 320px; text-align: left; border: 1px solid #333; }
        .btn { width: 100%; padding: 10px; margin: 5px 0; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; color: white; }
        .btn-blue { background-color: #007bff; }
        .btn-red { background-color: #dc3545; }
        .btn-gray { background-color: #6c757d; }
        .slider-group { margin-bottom: 12px; }
        label { display: flex; justify-content: space-between; font-size: 13px; color: #ccc; }
        input[type=range] { width: 100%; margin-top: 5px; }
        h4 { margin-top: 15px; margin-bottom: 10px; color: #fff; border-bottom: 1px solid #444; padding-bottom: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-container">
            <img src="/video_stream" width="640" height="480">
            <div style="position:absolute; top:5px; left:5px; color: yellow; text-shadow: 1px 1px 2px black; font-weight:bold;" id="mode_display">AO VIVO</div>
        </div>
        
        <div class="panel">
            <button class="btn btn-blue" onclick="triggerAuto()">ü™Ñ RECORTE AUTOM√ÅTICO (Geom√©trico)</button>
            <button class="btn btn-red" onclick="resetView()">‚ùå RESETAR TUDO</button>
            <button class="btn btn-gray" onclick="setMode('DEBUG')">üëÅÔ∏è MODO DEBUG (Ver Binariza√ß√£o)</button>

            <h4>‚úÇÔ∏è Recorte Manual (Ignora Borda)</h4>
            <div class="slider-group">
                <label>Topo (Y1): <span id="lbl_top">0%</span></label>
                <input type="range" id="roi_top" min="0" max="50" value="0" oninput="updateROI()">
            </div>
            <div class="slider-group">
                <label>Baixo (Y2): <span id="lbl_bottom">100%</span></label>
                <input type="range" id="roi_bottom" min="50" max="100" value="100" oninput="updateROI()">
            </div>
            <div class="slider-group">
                <label>Esquerda (X1): <span id="lbl_left">0%</span></label>
                <input type="range" id="roi_left" min="0" max="50" value="0" oninput="updateROI()">
            </div>
            <div class="slider-group">
                <label>Direita (X2): <span id="lbl_right">100%</span></label>
                <input type="range" id="roi_right" min="50" max="100" value="100" oninput="updateROI()">
            </div>

            <h4>üéõÔ∏è Ajustes de Detec√ß√£o</h4>
            <div class="slider-group">
                <label>Limiar Preto: <span id="val_thresh">180</span></label>
                <input type="range" id="inverted_thresh" min="100" max="254" value="180" oninput="updateParams()">
            </div>
            <div class="slider-group">
                <label>√Årea Min (Navio): <span id="val_area">300</span></label>
                <input type="range" id="max_oil_area" min="50" max="1000" value="300" oninput="updateParams()">
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            let countdown = 5;
            const display = document.getElementById('mode_display');
            const timer = setInterval(() => {
                display.innerText = "AUTO-START: " + countdown + "s";
                countdown--;
                if (countdown < 0) {
                    clearInterval(timer);
                    triggerAuto();
                }
            }, 1000);
        };

        function setMode(m) { fetch('/set_mode/'+m); document.getElementById('mode_display').innerText = m; }
        
        function triggerAuto() { 
            document.getElementById('mode_display').innerText = "BUSCANDO...";
            fetch('/trigger_auto_crop').then(r=>r.text()).then(msg => { 
                if(msg.includes("Falha")) {
                     document.getElementById('mode_display').innerText = "FALHA AUTO (USE MANUAL)";
                } else {
                     alert(msg); 
                }
                updateLabels(); 
            });
        }
        
        function resetView() { 
            fetch('/reset_view').then(() => {
                document.getElementById('roi_top').value = 0;
                document.getElementById('roi_bottom').value = 100;
                document.getElementById('roi_left').value = 0;
                document.getElementById('roi_right').value = 100;
                updateLabels();
                document.getElementById('mode_display').innerText = "AO VIVO";
            });
        }
        
        function updateROI() {
            const top = document.getElementById('roi_top').value;
            const bottom = document.getElementById('roi_bottom').value;
            const left = document.getElementById('roi_left').value;
            const right = document.getElementById('roi_right').value;
            
            document.getElementById('lbl_top').innerText = top + "%";
            document.getElementById('lbl_bottom').innerText = bottom + "%";
            document.getElementById('lbl_left').innerText = left + "%";
            document.getElementById('lbl_right').innerText = right + "%";

            fetch('/update_roi', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({top: top, bottom: bottom, left: left, right: right})
            });
        }

        function updateParams() {
            const params = {
                gamma: 1.0,
                inverted_thresh: document.getElementById('inverted_thresh').value,
                max_oil_area: document.getElementById('max_oil_area').value,
                ship_circ: 0.82
            };
            document.getElementById('val_thresh').innerText = params.inverted_thresh;
            document.getElementById('val_area').innerText = params.max_oil_area;
            fetch('/update_params', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(params) });
        }
        function updateLabels() {
             document.getElementById('lbl_top').innerText = document.getElementById('roi_top').value + "%";
             document.getElementById('lbl_bottom').innerText = document.getElementById('roi_bottom').value + "%";
             document.getElementById('lbl_left').innerText = document.getElementById('roi_left').value + "%";
             document.getElementById('lbl_right').innerText = document.getElementById('roi_right').value + "%";
        }
    </script>
</body>
</html>
"""

if __name__ == '__main__':
    t = threading.Thread(target=camera_loop)
    t.daemon = True
    t.start()
    app.run(host='0.0.0.0', port=5000, debug=False, threaded=True)
